package nodes

import (
	"context"
	"encoding/json"
	"log"
	"os"
	"sync"

	"golang.org/x/sync/errgroup"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

type NodeManager struct {
	mu    sync.Mutex
	nodes map[string]*Node
}

func NewNodeManager() *NodeManager {
	return &NodeManager{
		nodes: make(map[string]*Node),
	}
}

func (m *NodeManager) initNode(ctx context.Context, address string) (*NodeStatus, error) {
	conn, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		return nil, err
	}

	node, err := InitializeNode(ctx, conn)
	if err != nil {
		return nil, err
	}

	status, err := node.GetStatus(ctx)
	if err != nil {
		return nil, err
	}

	m.mu.Lock()
	defer m.mu.Unlock()
	m.nodes[node.NodeInfo.NodeName] = node

	return status, nil
}

func (m *NodeManager) AddNode(ctx context.Context, address string) (*NodeStatus, error) {

	status, err := m.initNode(ctx, address)

	err = m.writeToDisk()
	if err != nil {
		delete(m.nodes, status.NodeName)
		return nil, err
	}

	return status, nil
}

func (m *NodeManager) DeleteNode(ctx context.Context, nodeName string) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	delete(m.nodes, nodeName)

	if err := m.writeToDisk(); err != nil {
		return err
	}

	return nil
}

func (m *NodeManager) ListNodes() []*Node {
	m.mu.Lock()
	defer m.mu.Unlock()

	nodes := make([]*Node, 0, len(m.nodes))
	for _, n := range m.nodes {
		nodes = append(nodes, n)
	}
	return nodes
}

func (m *NodeManager) ListNodesInfo() ([]*NodeStatus, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	infos := make([]*NodeStatus, 0, len(m.nodes))
	for _, node := range m.nodes {
		info, err := node.GetStatus(context.Background())
		if err != nil {
			return nil, err
		}
		infos = append(infos, info)
	}

	return infos, nil
}

func (m *NodeManager) RemoveNode(nodeName string) error {
	m.mu.Lock()
	node, ok := m.nodes[nodeName]
	if ok {
		delete(m.nodes, nodeName)
	}
	m.mu.Unlock()

	if !ok {
		return ErrNodeNotExists
	}

	return node.NodeConn.Close()
}

func (m *NodeManager) GetNodeByName(ctx context.Context, nodeName string) (*Node, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	node, ok := m.nodes[nodeName]
	if !ok {
		return nil, ErrNodeNotExists
	}
	return node, nil
}

const nodesFile = "nodes.json"

func (m *NodeManager) writeToDisk() error {

	infos := make([]NodeInfo, 0, len(m.nodes))
	for _, n := range m.nodes {
		infos = append(infos, n.NodeInfo)
	}

	data, err := json.Marshal(infos)
	if err != nil {
		return err
	}

	return os.WriteFile("nodes.json", data, 0o644)
}

func (m *NodeManager) readFromDisk() ([]NodeInfo, error) {
	var infos []NodeInfo

	bytes, err := os.ReadFile("nodes.json")
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal(bytes, &infos); err != nil {
		return nil, err
	}

	return infos, err

}

func (m *NodeManager) Warmup(ctx context.Context) error {

	log.Print("warmup nodes")

	m.mu.Lock()
	nodeInfos, err := m.readFromDisk()
	m.mu.Unlock()
	if err != nil {
		return err
	}

	errGroup := errgroup.Group{}
	for _, nodeInfo := range nodeInfos {
		errGroup.Go(func() error {
			_, err := m.initNode(ctx, nodeInfo.NodeAddress)
			return err
		})
	}

	if err := errGroup.Wait(); err != nil {
		return err
	}

	return nil
}
