package bootstrap

import (
	"context"
	"crypto/ecdsa"
	"crypto/rand"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"errors"
	"fmt"
	apisecurityv1 "gofronet-foundation/gofro-control/gen/go/api/security/v1"
	"gofronet-foundation/gofro-control/internal/nodes/bootstrap/models"
	"gofronet-foundation/gofro-control/internal/security/certs"
	jwtutils "gofronet-foundation/gofro-control/internal/security/jwt_utils"
	"math/big"
	"strings"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

type BootstrapGrpcService struct {
	inviteStore      *InviteStore
	jwtSecretManager *jwtutils.JWTSecretManager
	apisecurityv1.UnimplementedBootstrapServiceServer
}

func NewBooststrapGrpcService(inviteStore *InviteStore, jwtSecretManager *jwtutils.JWTSecretManager) *BootstrapGrpcService {
	return &BootstrapGrpcService{
		inviteStore:      inviteStore,
		jwtSecretManager: jwtSecretManager,
	}
}

func (s *BootstrapGrpcService) Bootstrap(ctx context.Context, req *apisecurityv1.BootstrapRequest) (*apisecurityv1.BootstrapResponse, error) {
	_ = ctx

	token := strings.TrimSpace(req.GetBootstrapToken())
	if token == "" {
		return nil, status.Error(codes.InvalidArgument, "bootstrap_token is required")
	}

	csrPEM := strings.TrimSpace(req.GetCsr())
	if csrPEM == "" {
		return nil, status.Error(codes.InvalidArgument, "csr is required")
	}
	if len(csrPEM) > 16*1024 {
		return nil, status.Error(codes.InvalidArgument, "csr is too large")
	}

	csr, err := parseCSR(csrPEM)
	if err != nil {
		return nil, status.Error(codes.InvalidArgument, "invalid csr")
	}

	claims, err := s.jwtSecretManager.Verify(token, jwtutils.Issuer, jwtutils.Audience)
	if err != nil {
		return nil, status.Error(codes.Unauthenticated, "invalid bootstrap token")
	}

	scope, _ := claims["scope"].(string)
	if scope != "bootstrap" {
		return nil, status.Error(codes.PermissionDenied, "invalid bootstrap scope")
	}

	inviteID, err := claimAsString(claims, "invite_id")
	if err != nil {
		return nil, status.Error(codes.Unauthenticated, "invalid bootstrap token claims")
	}

	invite, err := s.inviteStore.GetInvite(inviteID)
	if err != nil {
		return nil, status.Error(codes.Unauthenticated, "invite not found")
	}

	if invite.Status != models.InviteStatusPending {
		return nil, status.Error(codes.FailedPrecondition, "invite is not pending")
	}

	if time.Now().After(invite.ExpireIn) {
		return nil, status.Error(codes.Unauthenticated, "invite is expired")
	}

	if err := s.inviteStore.DoneInvite(inviteID); err != nil {
		return nil, status.Error(codes.FailedPrecondition, "invite already consumed")
	}

	leafPEM, expiresUnix, err := signNodeCert(csr, inviteID)
	if err != nil {
		return nil, status.Error(codes.Internal, "failed to issue certificate")
	}

	return &apisecurityv1.BootstrapResponse{
		NodeId:      inviteID,
		LeafCert:    leafPEM,
		ExpiresUnix: expiresUnix,
	}, nil
}

func parseCSR(csrPEM string) (*x509.CertificateRequest, error) {
	block, _ := pem.Decode([]byte(csrPEM))
	if block == nil {
		return nil, errors.New("invalid csr pem")
	}
	if block.Type != "CERTIFICATE REQUEST" && block.Type != "NEW CERTIFICATE REQUEST" {
		return nil, fmt.Errorf("unexpected pem type: %s", block.Type)
	}

	csr, err := x509.ParseCertificateRequest(block.Bytes)
	if err != nil {
		return nil, err
	}
	if err := csr.CheckSignature(); err != nil {
		return nil, err
	}

	return csr, nil
}

func signNodeCert(csr *x509.CertificateRequest, nodeID string) ([]byte, int64, error) {
	rootCert, err := readCertPEM(certs.RootCertPath)
	if err != nil {
		return nil, 0, err
	}
	rootKey, err := readECPrivateKeyPKCS8PEM(certs.RootKeyPath)
	if err != nil {
		return nil, 0, err
	}

	serial, err := randSerial()
	if err != nil {
		return nil, 0, err
	}

	notBefore := time.Now().Add(-2 * time.Minute)
	notAfter := notBefore.Add(24 * time.Hour)

	tmpl := &x509.Certificate{
		SerialNumber: serial,
		Subject: pkix.Name{
			CommonName:   "node:" + nodeID,
			Organization: []string{"GofroNET"},
		},
		NotBefore: notBefore,
		NotAfter:  notAfter,

		BasicConstraintsValid: true,
		IsCA:                  false,

		KeyUsage:    x509.KeyUsageDigitalSignature,
		ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},
	}

	der, err := x509.CreateCertificate(rand.Reader, tmpl, rootCert, csr.PublicKey, rootKey)
	if err != nil {
		return nil, 0, err
	}

	leafPEM := pem.EncodeToMemory(&pem.Block{
		Type:  "CERTIFICATE",
		Bytes: der,
	})

	return leafPEM, notAfter.Unix(), nil
}

func readCertPEM(path string) (*x509.Certificate, error) {
	b, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("read cert pem: %w", err)
	}
	block, _ := pem.Decode(b)
	if block == nil || block.Type != "CERTIFICATE" {
		return nil, fmt.Errorf("invalid cert pem: %s", path)
	}
	c, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		return nil, fmt.Errorf("parse cert: %w", err)
	}
	return c, nil
}

func readECPrivateKeyPKCS8PEM(path string) (*ecdsa.PrivateKey, error) {
	b, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("read key pem: %w", err)
	}
	block, _ := pem.Decode(b)
	if block == nil {
		return nil, fmt.Errorf("invalid key pem: %s", path)
	}

	kAny, err := x509.ParsePKCS8PrivateKey(block.Bytes)
	if err != nil {
		return nil, fmt.Errorf("parse pkcs8 key: %w", err)
	}
	k, ok := kAny.(*ecdsa.PrivateKey)
	if !ok {
		return nil, fmt.Errorf("expected ECDSA private key in %s", path)
	}
	return k, nil
}

func randSerial() (*big.Int, error) {
	limit := new(big.Int).Lsh(big.NewInt(1), 128)
	return rand.Int(rand.Reader, limit)
}

func claimAsString(claims jwt.MapClaims, key string) (string, error) {
	v, ok := claims[key]
	if !ok {
		return "", fmt.Errorf("missing claim %q", key)
	}
	s, ok := v.(string)
	if !ok {
		return "", fmt.Errorf("claim %q is not string", key)
	}
	s = strings.TrimSpace(s)
	if s == "" {
		return "", fmt.Errorf("claim %q is empty", key)
	}
	return s, nil
}
